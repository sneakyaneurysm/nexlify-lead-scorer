## AI-Powered Lead Scoring Dashboard — Application Specification

### Executive Summary
AI-Powered Lead Scoring Dashboard prioritizes leads in Nexlify’s CRM using a simple, transparent model based on interaction data. It integrates with existing services and MongoDB, and ships as a React + Tailwind UI with an Express API service.
- Business goal: +15% conversion (~$750K ARR).
- Value: Actionable prioritization; improved CRM stickiness.
- MVP: Deterministic scoring (weighted sum), cached/persisted in MongoDB, sortable dashboard.

### High-Level Architecture
- Frontend: React (Next.js or Vite) with Tailwind CSS.
- Backend: Express API service route /leads/scoring.
- Data: MongoDB (interactions source; leadScores materialized cache).
- Integrations: User Mgmt (auth/owner), Analytics (optional interactions), GitHub + Linear + Notion.

```mermaid
flowchart LR
  subgraph Client
    U[Sales User]
  end
  subgraph Web[Web App]
    FE[React + Tailwind\nLeadScoringDashboard]
    API[/API Service\n/leads/scoring]
  end
  subgraph SVC[Existing Nexlify Services]
    UM[(User Mgmt)]
    AN[(Analytics)]
  end
  subgraph DB[Data Layer]
    MDB[(MongoDB\ninteractions, leadScores)]
    CACHE[(Redis Cache - optional)]
  end
  U --> FE
  FE -->|fetch leads| API
  API -->|auth/profile| UM
  API -->|fetch interactions| AN
  API -->|read/write| MDB
  API -->|cache| CACHE
```

### Scope
- In scope: React dashboard (sortable table); GET /leads/scoring; weighted-sum scoring; MongoDB read/write; Tailwind.
- Out of scope (MVP): Advanced ML; complex segmentation; websockets; AB tests; full RBAC UI.

### KPIs & Success Metrics
- Primary: Conversion uplift target +15%.
- Secondary: API P95 < 300 ms; TTI < 2.5s; >95% scores fresh within 15m; adoption by sales team.

### Personas & Journeys
- Sales Rep: Sort by score, action top leads.
- Sales Manager: Validate alignment; adjust thresholds.
- RevOps: Monitor data quality/performance.

### Functional Requirements
- LeadScoringDashboard.js
  - Columns: Lead Name, Score, Priority, Email Opens, Website Visits, Time Spent, Last Activity, Owner.
  - Sorting by Score (desc default), then Last Activity; clickable headers.
  - Filters: minScore; ownerId (optional); pagination (page/limit).
  - Refresh button + auto-refresh every 60s; loading/empty/error states; accessibility-compliant table.
- API (GET /leads/scoring)
  - Computes score on-demand or returns cached score; upserts into leadScores.
  - Query: limit (<=200), page (>=1), sort (score:desc|lastActivityAt:desc), minScore, ownerId, includeRaw, refresh.
  - Auth: Bearer JWT; tenant scoping.
  - Rate limited.

### Non-Functional Requirements
- Availability ≥99.9%; P95 <300 ms @ 100 RPS; JWT validation; input validation; structured logging; test coverage.

### Data Model
- interactions (read-only for feature)
  - tenantId, userId, leadId, emailOpens:number, websiteVisits:number, timeSpent:number(seconds), lastActivityAt:ISODate, updatedAt:ISODate
  - Indexes: {tenantId:1, leadId:1}; {tenantId:1, updatedAt:-1}
- leadScores (materialized cache)
  - tenantId, leadId, score:number(0–100), breakdown:{emailOpens, websiteVisits, timeSpent, decayFactor?}, computedAt:ISODate, lastActivityAt:ISODate, ownerId?
  - Indexes: {tenantId:1, score:-1}; {tenantId:1, computedAt:-1}; {tenantId:1, ownerId:1, score:-1}

### Scoring Algorithm (MVP)
- score_raw = w1*norm(emailOpens) + w2*norm(websiteVisits) + w3*norm(timeSpent)
- score = clamp01(score_raw) * decay(lastActivityAt) * 100
- Normalization caps: emailOpens cap=10 → x/10; websiteVisits cap=20 → x/20; timeSpent cap=600s → x/600 (values min-capped at 0).
- Default weights: w1=0.4, w2=0.35, w3=0.25 (env configurable).
- Time decay: half-life 7 days → decay = 0.5 ^ (days_since_last_activity/7).
- Store score and breakdown; return explainable fields.
- Config (env): LEAD_SCORE_WEIGHTS="0.4,0.35,0.25"; LEAD_SCORE_CAPS="10,20,600"; LEAD_SCORE_DECAY_HALFLIFE_DAYS=7.

### API Design
- GET /leads/scoring
  - Headers: Authorization: Bearer <jwt>
  - Query: limit (default 50, max 200), page (default 1), sort (default score:desc), minScore, ownerId, includeRaw=false, refresh=false
  - Response 200:
    - data: [{ tenantId, leadId, score, breakdown, lastActivityAt, ownerId?, raw? }]
    - meta: { page, limit, sort, minScore, refreshed }
  - Errors: 400 invalid params; 401 unauthorized; 429 rate limited; 500 internal error
- Behavior: Use cached scores if fresh (<= SCORE_FRESHNESS_MINUTES, default 15). If stale/not found or refresh=true → recompute from interactions and upsert. Always filter by tenantId from JWT.

### Front-End (LeadScoringDashboard.js)
- React + Tailwind; SWR for fetching/caching and auto-refresh.
- UI: Filters (minScore, owner); sortable headers; pagination; ScoreBadge; clear alignment for numeric columns.
- Accessibility: Proper table semantics, ARIA sort, focus states.
- Performance: Paginated requests; includeRaw only when needed.

### Deployment & Configuration
- Hosting: Containerized services (Express API and React UI); deploy to your chosen infra (e.g., Docker Compose, Kubernetes, or VM).
- Env Vars: MONGODB_URI, MONGODB_DB, JWT_ISSUER/JWKS_URI (or AUTH_SECRET), LEAD_SCORE_WEIGHTS, LEAD_SCORE_CAPS, LEAD_SCORE_DECAY_HALFLIFE_DAYS, SCORE_FRESHNESS_MINUTES=15.
- Secrets via environment variables; local dev via .env; Atlas networking via allowlist/peering.

### Security Considerations
- AuthN: Validate JWT (issuer, audience, signature).
- AuthZ: Tenant scoping; optional ownerId filter.
- Input Validation: Bounds-check query params; sanitize inputs.
- DB Access: Least-privileged role (read interactions; readWrite leadScores).
- PII: Limit to necessary fields; avoid logging PII.
- Rate Limiting: e.g., 60 RPM per user (configurable).

### Observability & Operations
- Structured logs (requestId, anonymized userId, tenantId, latency, DB timings); error logging.
- Metrics: scored leads count, cache hit ratio, stale vs recompute ratio, error rates.
- Optional tracing: OpenTelemetry; slow query logging (>100ms) for index review.

### Testing Strategy
- Unit: Scoring function (weights, caps, decay, rounding, edge cases).
- Integration: API with mongodb-memory-server; cache freshness behavior; filters/sort.
- UI: React Testing Library (sorting toggles, loading/empty/error states); light E2E (Playwright/Cypress) for sort/filter.
- CI: Lint + unit/integration tests on PR; coverage > 90% for scoring module.

### Performance & Scalability
- Query: interactions by tenantId with leadId; simple aggregation for lastActivityAt.
- Indexes: As above; page size capped.
- Caching: Optional Redis TTL = freshness window for top lists.
- Future: Scheduled batch recompute for active leads.

### Risks & Mitigations
- Data freshness drift → short freshness window + background refresh.
- Data quality gaps → show lastActivityAt and "no data" badge; robust defaults.
- Latency spikes → proper indexes; cap page size; degrade to cached scores when compute >300ms.
- Security misconfig → strict JWT validation; least-privileged DB roles; secrets only in env.

### Delivery Plan (30-minute MVP)
- 0–5m: Scaffold Next.js + Tailwind; create components/LeadScoringDashboard.js.
- 5–15m: Implement /api/leads/scoring, Mongo client, scoring function, env config.
- 15–20m: Build table with sorting/filters; SWR data fetching.
- 20–25m: Add minimal unit tests for scoring; API smoke test.
- 25–30m: Configure environment variables; deploy using your chosen platform; manual smoke.

### Open Questions
- Auth source (JWKS/JWT) details? OwnerId source? Tenancy model (shared vs per-tenant DB)? Lead display fields (name/email) source? Freshness target? Secondary sort tie-breaker?

### Future Enhancements
- ML models (logistic regression/GBM); feature flags; AB testing; websockets; CSV export; audit log; explainability view; usage analytics to auto-tune weights.

### Configuration Summary
- MONGODB_URI, MONGODB_DB
- JWT_ISSUER / JWKS_URI (or AUTH_SECRET)
- LEAD_SCORE_WEIGHTS="0.4,0.35,0.25"
- LEAD_SCORE_CAPS="10,20,600"
- LEAD_SCORE_DECAY_HALFLIFE_DAYS=7
- SCORE_FRESHNESS_MINUTES=15
